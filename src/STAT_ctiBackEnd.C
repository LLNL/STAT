#include "STAT_ctiBackEnd.h"
#include "common_tools_be.h"
#include <fstream>
#include <sstream>

STAT_ctiBackEnd::STAT_ctiBackEnd(StatDaemonLaunch_t launchType)
    : STAT_BackEnd(launchType)
{
    printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "Create CTI Backend.\n");
}

StatError_t STAT_ctiBackEnd::init(int *argc, char ***argv)
{
    printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "Initializing stat-cti backend\n");
    return STAT_BackEnd::init(argc, argv);
}

StatError_t STAT_ctiBackEnd::finalize()
{
    return STAT_OK;
}

// initialize cti
StatError_t STAT_ctiBackEnd::initLauncher()
{
    printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "Getting app processes.\n");

    // get the proc table
    cti_pidList_t* pids = cti_be_findAppPids();
    if (!pids)
    {
        printMsg(STAT_LMON_ERROR, __FILE__, __LINE__, "CTI failed to get processes.\n");
        return STAT_LMON_ERROR;
    }

    int n = pids->numPids;
    if (n <= 0) {
        printMsg(STAT_LMON_ERROR, __FILE__, __LINE__, "CTI found no procesess.\n");
        cti_be_destroyPidList(pids);
        return STAT_LMON_ERROR;
    }

    proctab_ = (StatBackEndProcInfo_t*) malloc(n * sizeof(StatBackEndProcInfo_t));
    for (int i=0; i<n; ++i) {
        auto pid = pids->pids[i].pid;

        // Get the executable for the process
        char exe[PATH_MAX+1];
        std::string procpath = "/proc/" + std::to_string(pid) + "/exe";
        ssize_t plen = readlink(procpath.c_str(), exe, PATH_MAX+1);
        if (plen <= 0 || plen == PATH_MAX+1) {
            printMsg(STAT_LMON_ERROR, __FILE__, __LINE__, "could not get application executable");
            cti_be_destroyPidList(pids);
            return STAT_LMON_ERROR;
        }
        
        proctab_[i].executable_name = strdup(exe);
        proctab_[i].host_name = nullptr;
        proctab_[i].pid = pid;
        proctab_[i].mpirank = pids->pids[i].rank;
    }
    proctabSize_ = n;

    cti_be_destroyPidList(pids);
    
    return STAT_OK;
}

#ifdef STAT_GDB_BE
StatError_t STAT_ctiBackEnd::initGdb()
{
    PyObject *pName;
    const char *moduleName = "stat_cuda_gdb";

    Py_Initialize();
#if PY_MAJOR_VERSION >= 3
    pName = PyUnicode_FromString(moduleName);
#else
    pName = PyString_FromString(moduleName);
#endif
    if (pName == NULL)
    {
        fprintf(errOutFp_, "Cannot convert argument\n");
        return STAT_SYSTEM_ERROR;
    }

    char* fileDir = cti_be_getFileDir();
    if (!fileDir) {
        fprintf(errOutFp_, "Cannot get CTI file directory\n");
        return STAT_SYSTEM_ERROR;
    }

    std::ostringstream os;
    os << "import sys\n";
    os << "sys.path.append('" << fileDir << "')\n";

    if (PyRun_SimpleString(os.str().c_str())) {
        fprintf(errOutFp_, "Setting python path fails\n");
    }
    
    gdbModule_ = PyImport_Import(pName);
    Py_DECREF(pName);
    if (gdbModule_ == NULL)
    {
        fprintf(errOutFp_, "Failed to import Python module %s\n", moduleName);
        PyErr_Print();
        return STAT_SYSTEM_ERROR;
    }
    usingGdb_ = true;

    std::string newFunctionName = "new_gdb_instance";
    auto newFunc = PyObject_GetAttrString(gdbModule_, newFunctionName.c_str());
    if (!newFunc || !PyCallable_Check(newFunc)) {
        if (PyErr_Occurred())
            PyErr_Print();
    }

    return STAT_OK;
}
#endif


// Open the connection file \a filename and return the input stream.
// The connection file is generated by the front end and broadcast via the
// CTI manifest, so we we may need to wait for it to show up.
static std::ifstream waitForConnectionFile(const std::string connectionFile)
{
    std::ifstream connections;
    static const int timeout = 60;  // seconds
    for (int attempt = 0; attempt < 100 * timeout; ++attempt) {
        connections.open(connectionFile.c_str());
        if (connections) {
            return connections;
        }
        usleep(10000);
    }
    return connections;
}

// Setting up the MRNet + cti tool takes a few steps:
//    1- launch the back-end processes (gives us the nodes involved)
//    2- then create the front and communication nodes of the MRNet tree (giving us
//             the set of parent nodes)
//    3- gather the parent connection information an broadcast via the cti manifest
//    4- each back-end node reads the connection file to find it's MRNet parent
//    5- with which it can create the back-end MRNet node
// When this function is called, steps 1 though 3 are already done.   This call performs steps
// 4 and 5.
StatError_t STAT_ctiBackEnd::connect(int argc, char **argv)
{
    printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "connecting backend\n");
    if (argc != 0) {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "not expecting arguments\n");
        return STAT_SYSTEM_ERROR;
    }

    // get the hostname
    char* hostnamePtr = cti_be_getNodeHostname();
    if (!hostnamePtr) {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "could not get hostname\n");
        return STAT_SYSTEM_ERROR;
    }

    std::string hostname(hostnamePtr);
    free(hostnamePtr);

    // Get the parent information so that we can connect this back end node to the mrnet tree.
    char* fileDir = cti_be_getFileDir();
    if (!fileDir) {
        printMsg(STAT_LMON_ERROR, __FILE__, __LINE__, "CTI failed to file dir.\n");
        return STAT_LMON_ERROR;
    }

    std::string connectionFile = std::string(fileDir) + "/daemoninfo.txt";

    free(fileDir);
    fileDir = nullptr;

    printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "trying to read file %s\n", connectionFile.c_str());
    std::ifstream connections = waitForConnectionFile(connectionFile);

    if (!connections) {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "could not open connection file %s\n",
                 connectionFile.c_str());
        return STAT_SYSTEM_ERROR;
    } else {
        printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "successfully opened connection file %s\n",
                 connectionFile.c_str());
    }


    // find the hostname in the connections files

    // The file starts with back-end hostnames : as hostname rank parentIndex
    int numHosts = 0;
    if (connections >> numHosts) {
        printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "got %d hosts\n", numHosts);
    } else {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "reading number of hosts failed\n");
    }

    if (!connections || numHosts <= 0) {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "could not get find parent connection info\n");
        return STAT_SYSTEM_ERROR;
    }

    int parentIdx = -1, mrnRank = -1;
    for (int hostIdx=0; connections && hostIdx < numHosts; ++hostIdx) {
        std::string host; int rank, pidx;
        connections >> host >> rank >> pidx;
        if (parentIdx < 0 && host == hostname) {
            parentIdx = pidx;
            mrnRank = rank;
        }
    }

    if (parentIdx < 0) {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "could not find host %s in host list\n",
                 hostname.c_str());
        return STAT_SYSTEM_ERROR;
    }

    // Then the connection info for the parents as: hostname port rank
    int numParents = 0;
    connections >> numParents;
    std::string parentHostname; int parentPort = -1, parentRank = -1;
    std::string phost; int pport, prank;
    for (int idx=0; connections && idx<numParents; ++idx) {
        if (!(connections >> phost >> pport >> prank))
            break;
        
        if (idx == parentIdx) {
            parentHostname = phost;
            parentPort = pport;
            parentRank = prank;
            break;
        }
    }

    if (parentHostname.empty()) {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "could not find parent info\n");
        return STAT_SYSTEM_ERROR;
    }

    // create the back-end MRNet node
    std::array<std::string,6> sbeArgs = { "",
                                          parentHostname,
                                          std::to_string(parentPort),
                                          std::to_string(parentRank),
                                          hostname,
                                          std::to_string(mrnRank) };
    char* beArgs[6];
    for (int i=0; i<6; ++i) {
        beArgs[i] = const_cast<char*>(sbeArgs[i].c_str());
    }

    for (int i=0; i<6; ++i) {
        printMsg(STAT_LOG_MESSAGE, __FILE__, __LINE__, "mrnet be arg[%d] = %s\n", i, beArgs[i]);
    }
                                           
    network_ = MRN::Network::CreateNetworkBE(6, beArgs);

    if (!network_) {
        printMsg(STAT_SYSTEM_ERROR, __FILE__, __LINE__, "back end network creation failed\n");
        return STAT_SYSTEM_ERROR;
    }

    // And Bob's your uncle.
    connected_ = true;

    return STAT_OK;
}

/******************
 * STATBench Code *
 ******************/

StatError_t STAT_ctiBackEnd::statBenchConnectInfoDump()
{
    printMsg(STAT_LMON_ERROR, __FILE__, __LINE__, "Statbench info dump not supported in CTI implementatioin.\n");
    return STAT_SYSTEM_ERROR;
}

#ifdef USE_CTI
STAT_BackEnd* STAT_BackEnd::make(StatDaemonLaunch_t launchType)
{
    return new STAT_ctiBackEnd(launchType);
}
#endif
