.\" auto-generated by docbook2man-spec from docbook-utils package
.TH "STAT-CL" "1" "2018-02-02" "" ""
.SH NAME
stat-cl \- invoke the Stack Trace Analysis Tool.
.SH SYNOPSIS
.sp
\fBstat-cl\fR [ \fB\fIOPTIONS\fB\fR ]  \fB\fIPID\fB\fR
.sp
\fBstat-cl\fR [ \fB\fIOPTIONS\fB\fR ]  \fB-C\fR \fB\fICOMMAND\fB\fR\fI...\fR
.PP
where
.sp
.nf
    
.sp
 [ \fB\fIOPTIONS\fB\fR ] 

    represents zero or more stat-cl options.
    
.sp
 \fB\fIPID\fB\fR

    is the PID of the parallel job launcher for the target application to attach to.
    
.sp
 \fB\fICOMMAND\fB\fR\fI...\fR

    is the command to launch the application.
    
.sp
.fi
.SH "DESCRIPTION"
.PP
STAT (the Stack Trace Analysis Tool) is a highly scalable, lightweight tool that gathers and merges stack traces from all of the processes of a parallel application. After running the \fBstat-cl\fR command, STAT will create a stat_results directory in your current working directory. This directory will contain a subdirectory, based on your parallel application's executable name, with the merged stack traces in DOT format.
.SH "OPTIONS"
.TP
\fB-a, --autotopo\fR
let STAT automatically create topology.
.TP
\fB-f, --fanout \fIwidth\fB\fR
Sets the maximum tree topology fanout to \fIwidth\fR\&. Specify nodes to launch communications processes on with \fB--nodes\fR\&.
.TP
\fB-d, --depth \fIdepth\fB\fR
Sets the tree topology depth to \fIdepth\fR\&. Specify nodes to launch communications processes on with \fB--nodes\fR\&.
.TP
\fB-z, --daemonspernode \fInum\fB\fR
Sets the number of daemons per node to \fInum\fR\&.
.TP
\fB-u, --usertopology \fItopology\fB\fR
Specify the number of communication nodes per layer in the tree topology, separated by dashes, with \fItopology\fR\&. Specify nodes to launch communications processes on with \fB--nodes\fR\&. Example topologies: 4, 4-16, 5-20-75.
.TP
\fB-n, --nodes \fInodelist\fB\fR
Use the specified nodes in \fInodelist\fR\&. To be used with \fB--fanout\fR, \fB--depth\fR, or \fB--usertopology\fR\&. Example nodes lists: host1; host1,host2; host[1,5-7,9].
.TP
\fB-N, --nodesfile \fIfilename\fB\fR
Use the file \fIfilename\fR, which should contain the list of nodes for communication processes
.TP
\fB-A, --appnodes\fR
Allow tool communication processes to be co-located on nodes running application processes.
.TP
\fB-x, --exclusive\fR
Do not use the front-end or back-end nodes for communication processes.
.TP
\fB-p, --procs \fIprocesses\fB\fR
Sets the maximum number of communication processes to be spawned per node to \fIprocesses\fR\&. This should typically be set to a number less than or equal to the number of CPU cores per node.
.TP
\fB-j, --jobid \fIid\fB\fR
Append \fIid\fR to the output directory and file prefixes. This is useful for associating STAT results with a batch job.
.TP
\fB-r, --retries \fIcount\fB\fR
Attempt \fIcount\fR retries per sample to try to get a complete stack trace.
.TP
\fB-R, --retryfreq \fIfrequency\fB\fR
Wait \fIfrequency\fR microseconds between sample retries. To be used with the \fB--retries\fR option.
.TP
\fB-P, --withpc\fR
Sample program counter values in addition to function names.
.TP
\fB-m, --withmoduleoffset\fR
Sample module offset only.
.TP
\fB-i, --withline\fR
Sample source line number in addition to function names.
.TP
\fB-o, --withopenmp\fR
Translate OpenMP stacks to logical application view
.TP
\fB-c, --comprehensive\fR
Gather 5 traces: function only; module offset; function + PC; function + line; and 3D function only.
.TP
\fB-U, --countrep\fR
Only gather edge labels with the task count and a single representative. This will improve performance at extreme (i.e., over 1 million tasks) scales.
.TP
\fB-w, --withthreads\fR
Sample stack traces from helper threads in addition to the main thread.
.TP
\fB-H, --maxdaemonthreads \fIcount\fB\fR
Allow sampling of up to \fIcount\fR threads per daemon.
.TP
\fB-y, --withpython\fR
Where applicable, gather Python script level stack traces, rather than show the Python interpreter stack traces. This requires the Python interpreter being debugged to be built with -g and preferrably -O0.
.TP
\fB-t, --traces \fIcount\fB\fR
Gather \fIcount\fR traces per process.
.TP
\fB-T, --tracefreq \fIfrequency\fB\fR
Wait \fIfrequency\fR milliseconds between samples. To be used with the \fB--traces\fR option.
.TP
\fB-S, --sampleindividual\fR
Save all individual samples in addition to the 3D trace when using \fB--traces\fR option.
.TP
\fB-C, --create \fIarg_list\fB\fR
Launch the application under STAT's control. All arguments after -C are used to launch the app. Namely, \fIarg_list\fR is the command that you would normally use to launch your application.
.TP
\fB-I, --serial \fIarg_list\fB\fR
Attach to a list of serial processes. All arguments after -I are interpreted as processes. Namely, \fIarg_list\fR is a white-space-separated list of processes to attach to, where each process is of the form [exe@][hostname:]PID.
.TP
\fB-D, --daemon \fIpath\fB\fR
Specify the full path \fIpath\fR to the STAT daemon executable. Use this only if you wish to override the default.
.TP
\fB-F, --filter \fIpath\fB\fR
Specify the full path \fIpath\fR to the STAT filter shared object. Use this only if you wish to override the default.
.TP
\fB-s, --sleep \fItime\fB\fR
Sleep for \fItime\fR seconds before attaching and gathering traces. This gives the application time to get to a hung state.
.TP
\fB-l, --log\fR
Enable debug logging of the \fIFE\fR frontend, \fIBE\fR backend, \fICP\fR communication process, \fISW\fR Stackwalker, \fISWERR\fR Stackwalker on error. Multiple log options may be specified (i.e., -l FE -l BE).
.TP
\fB-L, --logdir \fIlog_directory\fB\fR
Dump logging output into \fIlog_directory\fR\&. To be used with the \fB--log\fR option.
.TP
\fB-M, --mrnetprintf\fR
Use MRNet's printf for STAT debug logging.
.TP
\fB-X, --dysectapi \fIsession\fB\fR
Run the specified DySectAPI \fIsession\fR\&.
.TP
\fB-b, --dysectapi_batch \fIsecs\fB\fR
Run the specified DySectAPI in batch mode. Session stops after \fIsecs\fR seconds or detach action.
.TP
\fB-G, --gdb\fR
Use (cuda-)gdb to drive the daemons. If you are using cuda-gdb and want stack traces from cuda threads, you must also explicitly specify -w.
.TP
\fB-Q, --cudaquick\fR
When using cuda-gdb as the BE, gather less comprehensive, but faster cuda traces. Cuda frames will only show the top of the stack, not the full call path. This also defaults to display filename and line number and will not resolve the function name.
.SH "EXAMPLE"
.PP
The most typical usage is to invoke STAT on the job launcher's PID:
.PP
.sp
.nf
  % srun mpi_application arg1 arg2 &
  [1] 16842

  % ps
    PID TTY          TIME CMD
  16755 pts/0    00:00:00 bash
  16842 pts/0    00:00:00 srun
  16871 pts/0    00:00:00 ps

  % stat-cl 16842
    
.sp
.fi
.PP
Or for Flux, there is an additional step required:
.PP
.sp
.nf
  % flux mini run -n 8 mpi_application &
  [1] 216842

  % flux jobs -A
       JOBID USER     NAME       ST NTASKS NNODES  RUNTIME NODELIST
    fdB2peU7 lee218   a.out       R      8      2   12.89s fluke[6-7]
  % flux job attach --debug fdB2peU7&
  [3] 216853
  % stat-cl 216853
    
.sp
.fi
.PP
You can also launch your application under STAT's control with the \fB-C\fR option. All arguments after \fB-C\fR are used for job launch:
.PP
.sp
.nf
  % stat-cl -C srun mpi_application arg1 arg2
    
.sp
.fi
.PP
With the \fB-a\fR option (or when automatic topology is set as default), STAT will try to automatically create a scalable topology for large scale jobs. However, if you wish you may manually specify a topology at larger scales. For example, if you're running on 1024 nodes, you may want to try a fanout of sqrt(1024) = 32. You will need to specify a list of nodes that contains enough processors to accommodate the ceil(1024/32) = 32 communication processes being launched with the \fB--nodes\fR option. Be sure that you have login permissions to the specified nodes and that they contain the mrnet_commnode executable and the STAT_FilterDefinitions.so library.
.PP
.sp
.nf
  % stat-cl --fanout 32 --nodes atlas[1-4] --procs 8 16482
    
.sp
.fi
.PP
Upon successful completion, STAT will write its output to a stat_results directory within the current working directory. Each run creates a subdirectory named after the application with a unique integer ID. STAT's output indicates the directory created with a message such as:
.PP
.sp
.nf
  Results written to /home/user/bin/stat_results/mpi_application.6
    
.sp
.fi
.PP
Within that directory will be one or more files with a .dot extension. These .dot files can be viewed with \fBstat-view\fR\&.
.SH "AUTHOR"
.PP
(Written by ) Gregory  L.  Lee  
<lee218@llnl.gov>
.SH "COPYRIGHT"
.PP
Copyright 2007-2020 Lawrence Livermore National Laboratory
.PP
This is free software; see the source for copying conditions. There is NO warranty; not even for MECHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.SH "SEE ALSO"
.PP
\fBstat-gui\fR(1), \fBstat-view\fR(1), \fBstat-bench\fR(1)
